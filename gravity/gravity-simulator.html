<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Gravity Simulator</title>
    <meta name="description" content="Interactive simulator to explore gravitational attraction between bodies and observe emergent behavior from simple physical rules">
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: system-ui, -apple-system, sans-serif;
            background: #0a0a0a;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;

        // ============ CONSTANTS ============

        // Canvas dimensions
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;

        // Physics parameters
        const DT = 0.016;                    // Time step (~60 FPS)
        const MIN_DIST_SQ = 100;             // Minimum distance squared to prevent infinite forces
        const BOUNCE_DAMPING = 0.8;          // Energy retained on wall collision (20% lost)
        const RADIUS_FACTOR = 3;             // Particle radius = sqrt(mass) * RADIUS_FACTOR
        const INITIAL_MIN_MASS = 1;          // Minimum initial particle mass
        const INITIAL_MAX_MASS = 20;         // Maximum initial particle mass

        // Color mapping
        const MIN_MASS_COLOR = 1;            // Mass mapped to red (hue 0°)
        const MAX_MASS_COLOR = 50;           // Mass mapped to violet (hue 270°)
        const HUE_RANGE = 270;               // Degrees of hue spectrum used

        // ============ COMPONENT ============

        const GravitySimulator = () => {
          const canvasRef = useRef(null);
          const [particles, setParticles] = useState([]);
          const [isRunning, setIsRunning] = useState(false);
          const [language, setLanguage] = useState('en');
          const animationRef = useRef(null);
          
          // ============ STATE ============

          // Configurable parameters
          const [numParticles, setNumParticles] = useState(100);
          const [initialVelocity, setInitialVelocity] = useState(0.5);
          const [gravitationalConstant, setGravitationalConstant] = useState(100);

          // ============ TRANSLATIONS ============

          const texts = {
            it: {
              title: "Simulatore gravità 2D",
              subtitle: "Esplora l'attrazione gravitazionale tra particelle",
              description: "Questo simulatore mostra come le particelle interagiscono attraverso la forza di gravità. Le particelle si attraggono secondo la legge di Newton (F = G·m₁·m₂/r²) e si fondono quando collidono, conservando massa e quantità di moto.",
              concept: "Concetti chiave",
              concept1: "Legge di gravitazione universale: la forza è proporzionale al prodotto delle masse e inversamente proporzionale al quadrato della distanza",
              concept2: "Comportamento emergente: strutture complesse (ammassi) emergono da regole semplici",
              concept3: "Conservazione della quantità di moto: nelle collisioni, la massa totale e il momento si conservano",
              tryThis: "Prova questo",
              try1: "Aumenta G a 300-400: le particelle formano rapidamente ammassi compatti",
              try2: "Riduci G a 20-30: osserva movimenti più lenti e aggregazione graduale",
              try3: "Parti con poche particelle (20-30) per seguire meglio le interazioni individuali",
              controls: "Controlli",
              numParticles: "Numero particelle",
              initialVel: "Velocità iniziale",
              gravConstant: "Costante G",
              start: "Avvia",
              pause: "Pausa",
              reset: "Reset",
              activeParticles: "Particelle attive",
              legend: "Legenda colori",
              legendDesc: "Il colore indica la massa: rosso (piccola) → arancione → giallo → verde → blu → violetto (grande)",
              massRange: "Range massa attuale",
              credits: "Creato da",
              scientificNote: "Nota: questo è un modello semplificato per scopi didattici. I sistemi gravitazionali reali seguono le stesse leggi ma con scale e complessità molto maggiori."
            },
            en: {
              title: "2D gravity simulator",
              subtitle: "Explore gravitational attraction between particles",
              description: "This simulator shows how particles interact through gravitational force. Particles attract each other following Newton's law (F = G·m₁·m₂/r²) and merge when they collide, conserving mass and momentum.",
              concept: "Key concepts",
              concept1: "Universal gravitation law: force is proportional to the product of masses and inversely proportional to the square of distance",
              concept2: "Emergent behavior: complex structures (clusters) emerge from simple rules",
              concept3: "Momentum conservation: in collisions, total mass and momentum are conserved",
              tryThis: "Try this",
              try1: "Increase G to 300-400: particles quickly form compact clusters",
              try2: "Decrease G to 20-30: observe slower movements and gradual aggregation",
              try3: "Start with few particles (20-30) to better follow individual interactions",
              controls: "Controls",
              numParticles: "Number of particles",
              initialVel: "Initial velocity",
              gravConstant: "Constant G",
              start: "Start",
              pause: "Pause",
              reset: "Reset",
              activeParticles: "Active particles",
              legend: "Color legend",
              legendDesc: "Color indicates mass: red (small) → orange → yellow → green → blue → violet (large)",
              massRange: "Current mass range",
              credits: "Created by",
              scientificNote: "Note: this is a simplified model for educational purposes. Real gravitational systems follow the same laws but at much larger scales and complexity."
            }
          };
          
          const t = texts[language];

          // ============ HELPERS ============

          // Convert mass to color (red → violet following spectrum)
          const massToColor = (mass) => {
            const normalized = Math.min(Math.max((mass - MIN_MASS_COLOR) / (MAX_MASS_COLOR - MIN_MASS_COLOR), 0), 1);
            const hue = normalized * HUE_RANGE;
            return `hsl(${hue}, 80%, 50%)`;
          };

          // Calculate particle statistics for dynamic legend
          const particleStats = useMemo(() => {
            const alive = particles.filter(p => p.alive);
            if (alive.length === 0) return { minMass: 0, maxMass: 0, count: 0 };

            const masses = alive.map(p => p.mass);
            return {
              minMass: Math.min(...masses),
              maxMass: Math.max(...masses),
              count: alive.length
            };
          }, [particles]);

          // ============ PARTICLE MANAGEMENT ============

          // Initialize particles with random positions and velocities
          const initializeParticles = () => {
            const newParticles = [];
            const massRange = INITIAL_MAX_MASS - INITIAL_MIN_MASS;
            for (let i = 0; i < numParticles; i++) {
              const mass = INITIAL_MIN_MASS + Math.random() * massRange;
              const angle = Math.random() * Math.PI * 2;
              newParticles.push({
                id: i,
                x: Math.random() * CANVAS_WIDTH,
                y: Math.random() * CANVAS_HEIGHT,
                vx: Math.cos(angle) * initialVelocity,
                vy: Math.sin(angle) * initialVelocity,
                mass: mass,
                radius: Math.sqrt(mass) * RADIUS_FACTOR,
                alive: true
              });
            }
            setParticles(newParticles);
          };
          
          // Reset simulazione
          const handleReset = () => {
            setIsRunning(false);
            if (animationRef.current) {
              cancelAnimationFrame(animationRef.current);
            }
            initializeParticles();
          };
          
          // Toggle play/pause
          const toggleSimulation = () => {
            setIsRunning(!isRunning);
          };

          // ============ PHYSICS ============

          const CELL_SIZE = 50; // Spatial grid cell size for collision detection

          // Build spatial hash grid for efficient collision detection
          const buildSpatialGrid = (particles) => {
            const grid = new Map();
            const cols = Math.ceil(CANVAS_WIDTH / CELL_SIZE);

            particles.forEach((p, idx) => {
              if (!p.alive) return;
              const cellX = Math.floor(p.x / CELL_SIZE);
              const cellY = Math.floor(p.y / CELL_SIZE);
              const key = cellY * cols + cellX;

              if (!grid.has(key)) grid.set(key, []);
              grid.get(key).push(idx);
            });

            return { grid, cols };
          };

          // Get neighboring cell indices for collision checks
          const getNeighborIndices = (x, y, cols, rows) => {
            const neighbors = [];
            for (let dy = -1; dy <= 1; dy++) {
              for (let dx = -1; dx <= 1; dx++) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
                  neighbors.push(ny * cols + nx);
                }
              }
            }
            return neighbors;
          };

          // Calculate gravitational forces and update positions
          const updatePhysics = useCallback((parts) => {
            let particles = parts.filter(p => p.alive).map(p => ({...p}));
            const newParticles = []; // For merged particles

            // Build spatial grid for collision detection
            const cols = Math.ceil(CANVAS_WIDTH / CELL_SIZE);
            const rows = Math.ceil(CANVAS_HEIGHT / CELL_SIZE);
            const { grid } = buildSpatialGrid(particles);

            // Track which particles have been merged
            const merged = new Set();

            // Phase 1: Detect collisions using spatial hashing and create merged particles
            for (let i = 0; i < particles.length; i++) {
              if (!particles[i].alive || merged.has(i)) continue;

              const pi = particles[i];
              const cellX = Math.floor(pi.x / CELL_SIZE);
              const cellY = Math.floor(pi.y / CELL_SIZE);
              const neighborKeys = getNeighborIndices(cellX, cellY, cols, rows);

              for (const key of neighborKeys) {
                const cell = grid.get(key);
                if (!cell) continue;

                for (const j of cell) {
                  if (i >= j || !particles[j].alive || merged.has(j)) continue;

                  const pj = particles[j];
                  const dx = pj.x - pi.x;
                  const dy = pj.y - pi.y;
                  const dist = Math.sqrt(dx * dx + dy * dy);

                  // Check collision
                  if (dist < pi.radius + pj.radius) {
                    // Barycenter fusion: create new particle at center of mass
                    const totalMass = pi.mass + pj.mass;

                    // Position: mass-weighted barycenter
                    const newX = (pi.x * pi.mass + pj.x * pj.mass) / totalMass;
                    const newY = (pi.y * pi.mass + pj.y * pj.mass) / totalMass;

                    // Velocity: momentum conservation
                    const newVx = (pi.vx * pi.mass + pj.vx * pj.mass) / totalMass;
                    const newVy = (pi.vy * pi.mass + pj.vy * pj.mass) / totalMass;

                    // Create merged particle
                    newParticles.push({
                      id: `merged_${pi.id}_${pj.id}`,
                      x: newX,
                      y: newY,
                      vx: newVx,
                      vy: newVy,
                      mass: totalMass,
                      radius: Math.sqrt(totalMass) * RADIUS_FACTOR,
                      alive: true
                    });

                    // Mark both as merged
                    merged.add(i);
                    merged.add(j);
                    particles[i].alive = false;
                    particles[j].alive = false;
                    break; // Stop checking collisions for particle i
                  }
                }
                if (merged.has(i)) break;
              }
            }

            // Combine surviving particles with newly merged ones
            const allParticles = [
              ...particles.filter((p, idx) => p.alive && !merged.has(idx)),
              ...newParticles
            ];

            // Phase 2: Calculate gravitational forces (O(n²) but with alive check)
            const forces = allParticles.map(() => ({ fx: 0, fy: 0 }));

            for (let i = 0; i < allParticles.length; i++) {
              for (let j = i + 1; j < allParticles.length; j++) {
                const pi = allParticles[i];
                const pj = allParticles[j];

                const dx = pj.x - pi.x;
                const dy = pj.y - pi.y;
                const distSq = dx * dx + dy * dy;
                const dist = Math.sqrt(distSq);

                // Gravitational force: F = G * m1 * m2 / r²
                const force = gravitationalConstant * pi.mass * pj.mass / Math.max(distSq, MIN_DIST_SQ);
                const fx = force * dx / dist;
                const fy = force * dy / dist;

                // Newton's third law: equal and opposite
                forces[i].fx += fx;
                forces[i].fy += fy;
                forces[j].fx -= fx;
                forces[j].fy -= fy;
              }
            }

            // Phase 3: Update velocities and positions
            for (let i = 0; i < allParticles.length; i++) {
              const p = allParticles[i];

              // Update velocity (F = ma, so a = F/m)
              p.vx += (forces[i].fx / p.mass) * DT;
              p.vy += (forces[i].fy / p.mass) * DT;

              // Update position
              p.x += p.vx * DT;
              p.y += p.vy * DT;

              // Bounce off walls
              if (p.x < p.radius) {
                p.x = p.radius;
                p.vx *= -BOUNCE_DAMPING;
              }
              if (p.x > CANVAS_WIDTH - p.radius) {
                p.x = CANVAS_WIDTH - p.radius;
                p.vx *= -BOUNCE_DAMPING;
              }
              if (p.y < p.radius) {
                p.y = p.radius;
                p.vy *= -BOUNCE_DAMPING;
              }
              if (p.y > CANVAS_HEIGHT - p.radius) {
                p.y = CANVAS_HEIGHT - p.radius;
                p.vy *= -BOUNCE_DAMPING;
              }
            }

            return allParticles;
          }, [gravitationalConstant]);
          
          // ============ EFFECTS ============

          // Rendering
          useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Only iterate over alive particles (already filtered by updatePhysics)
            const aliveParticles = particles.filter(p => p.alive);
            aliveParticles.forEach(p => {
              ctx.fillStyle = massToColor(p.mass);
              ctx.beginPath();
              ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
              ctx.fill();
            });
          }, [particles]);

          // Animation loop
          useEffect(() => {
            if (!isRunning) return;

            const animate = () => {
              setParticles(prevParticles => updatePhysics(prevParticles));
              animationRef.current = requestAnimationFrame(animate);
            };

            animationRef.current = requestAnimationFrame(animate);
            
            return () => {
              if (animationRef.current) {
                cancelAnimationFrame(animationRef.current);
              }
            };
          }, [isRunning, updatePhysics]);

          // Initialize on mount and when parameters change
          useEffect(() => {
            if (!isRunning) {
              initializeParticles();
            }
          }, [numParticles, initialVelocity]);

          // ============ RENDER ============

          return (
            <div className="flex flex-col items-center gap-6 p-6 bg-gray-900 min-h-screen">
              {/* Language toggle */}
              <div className="self-end">
                <div className="flex gap-2 bg-gray-800 rounded-lg p-1">
                  <button 
                    onClick={() => setLanguage('it')}
                    className={`px-4 py-2 rounded-md font-semibold transition ${
                      language === 'it' 
                        ? 'bg-blue-600 text-white' 
                        : 'text-gray-400 hover:text-white'
                    }`}
                  >
                    IT
                  </button>
                  <button 
                    onClick={() => setLanguage('en')}
                    className={`px-4 py-2 rounded-md font-semibold transition ${
                      language === 'en' 
                        ? 'bg-blue-600 text-white' 
                        : 'text-gray-400 hover:text-white'
                    }`}
                  >
                    EN
                  </button>
                </div>
              </div>
              
              {/* Header */}
              <div className="text-center max-w-4xl">
                <h1 className="text-4xl font-bold text-white mb-2">{t.title}</h1>
                <p className="text-xl text-gray-400">{t.subtitle}</p>
              </div>
              
              {/* Description */}
              <div className="bg-gray-800 p-6 rounded-lg max-w-4xl w-full">
                <p className="text-gray-300 leading-relaxed">{t.description}</p>
              </div>
              
              {/* Canvas */}
              <canvas
                ref={canvasRef}
                width={CANVAS_WIDTH}
                height={CANVAS_HEIGHT}
                className="border-2 border-gray-700 rounded-lg shadow-2xl"
              />
              
              {/* Controls */}
              <div className="bg-gray-800 p-6 rounded-lg shadow-lg w-full max-w-4xl">
                <h3 className="text-xl font-bold text-white mb-4">{t.controls}</h3>
                
                <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                  <div>
                    <label className="block text-white mb-2 text-sm">
                      {t.numParticles}: <span className="font-bold">{numParticles}</span>
                    </label>
                    <input
                      type="range"
                      min="10"
                      max="200"
                      value={numParticles}
                      onChange={(e) => setNumParticles(parseInt(e.target.value))}
                      disabled={isRunning}
                      className="w-full disabled:cursor-not-allowed disabled:opacity-50"
                    />
                  </div>
                  
                  <div>
                    <label className="block text-white mb-2 text-sm">
                      {t.initialVel}: <span className="font-bold">{initialVelocity.toFixed(2)}</span>
                    </label>
                    <input
                      type="range"
                      min="0"
                      max="3"
                      step="0.1"
                      value={initialVelocity}
                      onChange={(e) => setInitialVelocity(parseFloat(e.target.value))}
                      disabled={isRunning}
                      className="w-full disabled:cursor-not-allowed disabled:opacity-50"
                    />
                  </div>
                  
                  <div>
                    <label className="block text-white mb-2 text-sm">
                      {t.gravConstant}: <span className="font-bold">{gravitationalConstant}</span>
                    </label>
                    <input
                      type="range"
                      min="10"
                      max="500"
                      step="10"
                      value={gravitationalConstant}
                      onChange={(e) => setGravitationalConstant(parseInt(e.target.value))}
                      className="w-full"
                    />
                  </div>
                </div>

                <div className="flex gap-4 justify-center mb-6">
                  <button
                    onClick={toggleSimulation}
                    className="px-8 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-semibold transition"
                  >
                    {isRunning ? t.pause : t.start}
                  </button>
                  
                  <button
                    onClick={handleReset}
                    className="px-8 py-3 bg-red-600 hover:bg-red-700 text-white rounded-lg font-semibold transition"
                  >
                    {t.reset}
                  </button>
                </div>
                
                <div className="text-gray-300 text-sm">
                  <p><span className="font-bold">{t.activeParticles}:</span> {particleStats.count}</p>
                </div>
              </div>

              {/* Color legend */}
              <div className="bg-gray-800 p-6 rounded-lg max-w-4xl w-full">
                <h3 className="text-xl font-bold text-white mb-3">{t.legend}</h3>
                <p className="text-gray-300 mb-3">{t.legendDesc}</p>
                <div className="flex items-center gap-2">
                  <span className="text-white text-sm font-mono">{particleStats.minMass.toFixed(1)}</span>
                  <div className="flex-1 h-8 rounded" style={{
                    background: 'linear-gradient(to right, hsl(0, 80%, 50%), hsl(30, 80%, 50%), hsl(60, 80%, 50%), hsl(120, 80%, 50%), hsl(210, 80%, 50%), hsl(270, 80%, 50%))'
                  }}></div>
                  <span className="text-white text-sm font-mono">{particleStats.maxMass.toFixed(1)}</span>
                </div>
                <p className="text-gray-400 text-xs mt-2">{t.massRange}: {particleStats.minMass.toFixed(1)} - {particleStats.maxMass.toFixed(1)}</p>
              </div>
              
              {/* Key concepts */}
              <div className="bg-gray-800 p-6 rounded-lg max-w-4xl w-full">
                <h3 className="text-xl font-bold text-white mb-4">{t.concept}</h3>
                <ul className="space-y-3 text-gray-300">
                  <li className="flex gap-3">
                    <span className="text-blue-400 font-bold">•</span>
                    <span>{t.concept1}</span>
                  </li>
                  <li className="flex gap-3">
                    <span className="text-blue-400 font-bold">•</span>
                    <span>{t.concept2}</span>
                  </li>
                  <li className="flex gap-3">
                    <span className="text-blue-400 font-bold">•</span>
                    <span>{t.concept3}</span>
                  </li>
                </ul>
              </div>
              
              {/* Try this */}
              <div className="bg-gray-800 p-6 rounded-lg max-w-4xl w-full">
                <h3 className="text-xl font-bold text-white mb-4">{t.tryThis}</h3>
                <ul className="space-y-2 text-gray-300">
                  <li className="flex gap-3">
                    <span className="text-green-400 font-bold">→</span>
                    <span>{t.try1}</span>
                  </li>
                  <li className="flex gap-3">
                    <span className="text-green-400 font-bold">→</span>
                    <span>{t.try2}</span>
                  </li>
                  <li className="flex gap-3">
                    <span className="text-green-400 font-bold">→</span>
                    <span>{t.try3}</span>
                  </li>
                </ul>
              </div>
              
              {/* Scientific note */}
              <div className="bg-gray-800 p-4 rounded-lg max-w-4xl w-full">
                <p className="text-gray-400 text-sm italic">{t.scientificNote}</p>
              </div>
              
              {/* Credits */}
              <div className="text-gray-400 text-sm mt-4">
                <p>
                  {t.credits}{' '}
                  <a 
                    href="https://ai-know.pro" 
                    target="_blank" 
                    rel="noopener noreferrer"
                    className="text-blue-400 hover:text-blue-300 transition"
                  >
                    Paolo Dalprato
                  </a>
                </p>
              </div>
            </div>
          );
        };

        ReactDOM.render(<GravitySimulator />, document.getElementById('root'));
    </script>
</body>
</html>