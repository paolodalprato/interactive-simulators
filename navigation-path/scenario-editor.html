<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scenario Editor - Branching Navigator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #e0e0e0;
            min-height: 100vh;
        }
        
        .editor-container {
            display: flex;
            height: 100vh;
        }
        
        /* Sidebar */
        .sidebar {
            width: 280px;
            background: #16213e;
            border-right: 1px solid #2a2a4a;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }
        
        .sidebar-header {
            padding: 1rem;
            border-bottom: 1px solid #2a2a4a;
        }
        
        .sidebar-header h1 {
            font-size: 1.25rem;
            margin: 0 0 0.5rem 0;
            color: #fff;
        }
        
        .sidebar-actions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: #6366f1;
            color: white;
        }
        
        .btn-primary:hover {
            background: #5558e3;
        }
        
        .btn-secondary {
            background: #374151;
            color: #e0e0e0;
        }
        
        .btn-secondary:hover {
            background: #4b5563;
        }
        
        .btn-success {
            background: #10b981;
            color: white;
        }
        
        .btn-success:hover {
            background: #059669;
        }
        
        .btn-danger {
            background: #ef4444;
            color: white;
        }
        
        .btn-danger:hover {
            background: #dc2626;
        }
        
        /* Node list */
        .node-list {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }
        
        .node-item {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: #1a1a2e;
            border-radius: 8px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        
        .node-item:hover {
            border-color: #4b5563;
        }
        
        .node-item.selected {
            border-color: #6366f1;
            background: #1e1e3f;
        }
        
        .node-item.start-node {
            border-left: 3px solid #10b981;
        }
        
        .node-item.terminal {
            border-left: 3px solid #f59e0b;
        }
        
        .node-id {
            font-weight: 600;
            color: #fff;
            font-size: 0.9rem;
        }
        
        .node-title {
            font-weight: 600;
            color: #fff;
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .node-id-small {
            font-size: 0.7rem;
            color: #6b7280;
            font-family: monospace;
            margin-top: 0.15rem;
        }
        
        .node-preview {
            font-size: 0.75rem;
            color: #9ca3af;
            margin-top: 0.25rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .node-badges {
            display: flex;
            gap: 0.25rem;
            margin-top: 0.5rem;
        }
        
        .badge {
            font-size: 0.65rem;
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
            background: #374151;
            color: #9ca3af;
        }
        
        .badge-start {
            background: #065f46;
            color: #6ee7b7;
        }
        
        .badge-terminal {
            background: #78350f;
            color: #fcd34d;
        }
        
        /* Main editor area */
        .main-editor {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .editor-header {
            padding: 1rem;
            background: #16213e;
            border-bottom: 1px solid #2a2a4a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .editor-content {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }
        
        .form-section {
            background: #16213e;
            border-radius: 8px;
            padding: 1.25rem;
            margin-bottom: 1.5rem;
        }
        
        .form-section h3 {
            margin: 0 0 1rem 0;
            font-size: 1rem;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .form-group {
            margin-bottom: 1rem;
        }
        
        .form-group:last-child {
            margin-bottom: 0;
        }
        
        .form-label {
            display: block;
            font-size: 0.8rem;
            color: #9ca3af;
            margin-bottom: 0.4rem;
        }
        
        .form-input {
            width: 100%;
            padding: 0.6rem 0.75rem;
            border-radius: 6px;
            border: 1px solid #374151;
            background: #1a1a2e;
            color: #e0e0e0;
            font-size: 0.9rem;
        }
        
        .form-input:focus {
            outline: none;
            border-color: #6366f1;
        }
        
        .form-textarea {
            min-height: 120px;
            resize: vertical;
            font-family: monospace;
        }
        
        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }
        
        /* Choices editor */
        .choice-item {
            background: #1a1a2e;
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            border: 1px solid #374151;
        }
        
        .choice-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }
        
        .choice-number {
            font-size: 0.8rem;
            color: #6366f1;
            font-weight: 600;
        }
        
        /* Resources editor */
        .resource-item {
            background: #1a1a2e;
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            border: 1px solid #374151;
        }
        
        .resource-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }
        
        .form-select {
            padding: 0.6rem 0.75rem;
            border-radius: 6px;
            border: 1px solid #374151;
            background: #1a1a2e;
            color: #e0e0e0;
            font-size: 0.9rem;
        }
        
        .form-select:focus {
            outline: none;
            border-color: #6366f1;
        }
        
        /* Add button */
        .add-button {
            width: 100%;
            padding: 0.75rem;
            border: 2px dashed #374151;
            border-radius: 6px;
            background: transparent;
            color: #6b7280;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }
        
        .add-button:hover {
            border-color: #6366f1;
            color: #6366f1;
        }
        
        /* Meta editor */
        .meta-editor {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        
        .meta-editor-content {
            background: #16213e;
            border-radius: 12px;
            padding: 1.5rem;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .meta-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        
        .meta-editor-header h2 {
            margin: 0;
            color: #fff;
        }
        
        /* Empty state */
        .empty-state {
            text-align: center;
            padding: 3rem;
            color: #6b7280;
        }
        
        .empty-state h2 {
            color: #9ca3af;
            margin-bottom: 0.5rem;
        }
        
        /* Status bar */
        .status-bar {
            padding: 0.5rem 1rem;
            background: #0f0f1a;
            border-top: 1px solid #2a2a4a;
            font-size: 0.75rem;
            color: #6b7280;
            display: flex;
            justify-content: space-between;
        }
        
        .status-saved {
            color: #10b981;
        }
        
        .status-unsaved {
            color: #f59e0b;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #1a1a2e;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #374151;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #4b5563;
        }
        
        /* Hidden file input */
        .hidden-input {
            display: none;
        }
        
        /* Map overlay */
        .map-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 10, 20, 0.95);
            z-index: 200;
            display: flex;
            flex-direction: column;
        }
        
        .map-overlay-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #2a2a4a;
            background: #16213e;
        }
        
        .map-overlay-header h2 {
            margin: 0;
            color: #fff;
            font-size: 1.25rem;
        }
        
        .map-legend {
            display: flex;
            gap: 1.5rem;
            font-size: 0.8rem;
            color: #9ca3af;
        }
        
        .map-legend span {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        
        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 3px;
            border: 2px solid;
        }
        
        .legend-start {
            border-color: #10b981;
            background: #065f46;
        }
        
        .legend-terminal {
            border-color: #f59e0b;
            background: #78350f;
        }
        
        .legend-selected {
            border-color: #818cf8;
            background: #3730a3;
        }
        
        .legend-orphan {
            border-color: #ef4444;
            background: #7f1d1d;
        }
        
        .map-overlay-content {
            flex: 1;
            overflow: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }
        
        /* Create Node Popup */
        .create-node-popup {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 300;
        }
        
        .create-node-content {
            background: #16213e;
            border-radius: 12px;
            padding: 1.5rem;
            width: 90%;
            max-width: 550px;
            max-height: 90vh;
            overflow-y: auto;
            border: 1px solid #2a2a4a;
        }
        
        .create-node-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.25rem;
        }
        
        .create-node-header h3 {
            margin: 0;
            color: #fff;
            font-size: 1.1rem;
        }
        
        .form-info {
            font-size: 0.8rem;
            color: #6b7280;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        
        // ============================================================
        // Utility: Calculate node levels in tree
        // ============================================================
        const calculateNodeLevels = (nodes, startNode) => {
            const levels = {};
            const visited = new Set();
            const queue = [{ id: startNode, level: 1 }];
            
            while (queue.length > 0) {
                const { id, level } = queue.shift();
                if (visited.has(id) || !nodes[id]) continue;
                visited.add(id);
                
                if (!levels[level]) levels[level] = [];
                levels[level].push(id);
                
                const choices = nodes[id].choices || [];
                choices.forEach(choice => {
                    if (choice.next && !visited.has(choice.next)) {
                        queue.push({ id: choice.next, level: level + 1 });
                    }
                });
            }
            
            // Add orphan nodes (not reachable from start)
            Object.keys(nodes).forEach(id => {
                if (!visited.has(id)) {
                    if (!levels[0]) levels[0] = [];
                    levels[0].push(id);
                }
            });
            
            return levels;
        };
        
        const getNodeLevel = (nodeId, nodes, startNode) => {
            const levels = calculateNodeLevels(nodes, startNode);
            for (const [level, nodeIds] of Object.entries(levels)) {
                if (nodeIds.includes(nodeId)) {
                    return { level: parseInt(level), position: nodeIds.indexOf(nodeId) + 1 };
                }
            }
            return { level: 0, position: 1 };
        };
        
        const suggestNodeId = (nodes, startNode, parentNodeId) => {
            const parentInfo = getNodeLevel(parentNodeId, nodes, startNode);
            const newLevel = parentInfo.level > 0 ? parentInfo.level + 1 : 2;
            
            // Count existing nodes at this level
            const levels = calculateNodeLevels(nodes, startNode);
            const nodesAtLevel = levels[newLevel] || [];
            const position = nodesAtLevel.length + 1;
            
            // Format: n_LL_PP_from_PARENT (where LL=level, PP=position)
            const levelStr = String(newLevel).padStart(2, '0');
            const posStr = String(position).padStart(2, '0');
            
            if (parentNodeId && parentNodeId !== startNode) {
                // Extract parent's position info for shorter reference
                const parentShort = parentNodeId.replace('n_', '').slice(0, 5);
                return `n_${levelStr}_${posStr}_from_${parentShort}`;
            }
            
            return `n_${levelStr}_${posStr}`;
        };
        
        // ============================================================
        // Tree Map Overlay Component (Full Screen)
        // ============================================================
        const TreeMapOverlay = ({ nodes, startNode, selectedNode, onSelectNode, onClose }) => {
            const levels = calculateNodeLevels(nodes, startNode);
            const maxLevel = Math.max(...Object.keys(levels).map(Number), 1);
            
            const levelHeight = 100;
            const nodeWidth = 140;
            const nodeHeight = 44;
            const padding = 60;
            
            // Calculate positions
            const positions = {};
            let maxWidth = 0;
            
            Object.entries(levels).forEach(([level, nodeIds]) => {
                const totalWidth = nodeIds.length * nodeWidth;
                maxWidth = Math.max(maxWidth, totalWidth);
            });
            
            Object.entries(levels).forEach(([level, nodeIds]) => {
                const levelNum = parseInt(level);
                const totalWidth = nodeIds.length * nodeWidth;
                const startX = (maxWidth - totalWidth) / 2 + nodeWidth / 2;
                
                nodeIds.forEach((nodeId, index) => {
                    positions[nodeId] = {
                        x: startX + index * nodeWidth + padding,
                        y: levelNum * levelHeight + padding
                    };
                });
            });
            
            const svgWidth = maxWidth + padding * 2;
            const svgHeight = (maxLevel + 1) * levelHeight + padding;
            
            // Build connections
            const connections = [];
            Object.entries(nodes).forEach(([nodeId, node]) => {
                if (node.choices && positions[nodeId]) {
                    node.choices.forEach(choice => {
                        if (choice.next && positions[choice.next]) {
                            connections.push({
                                from: positions[nodeId],
                                to: positions[choice.next]
                            });
                        }
                    });
                }
            });
            
            const isTerminal = (nodeId) => {
                return !nodes[nodeId]?.choices || nodes[nodeId].choices.length === 0;
            };
            
            const isOrphan = (nodeId) => {
                const info = getNodeLevel(nodeId, nodes, startNode);
                return info.level === 0;
            };
            
            return (
                <div className="map-overlay">
                    <div className="map-overlay-header">
                        <h2>Scenario Map</h2>
                        <div className="map-legend">
                            <span><span className="legend-dot legend-start"></span> Start</span>
                            <span><span className="legend-dot legend-terminal"></span> Terminal</span>
                            <span><span className="legend-dot legend-selected"></span> Selected</span>
                            <span><span className="legend-dot legend-orphan"></span> Orphan</span>
                        </div>
                        <button className="btn btn-secondary" onClick={onClose}>‚úï Close</button>
                    </div>
                    <div className="map-overlay-content">
                        <svg width={Math.max(svgWidth, 400)} height={Math.max(svgHeight, 300)} style={{ display: 'block', margin: 'auto' }}>
                            {/* Connections */}
                            {connections.map((conn, index) => (
                                <line
                                    key={`conn-${index}`}
                                    x1={conn.from.x}
                                    y1={conn.from.y + nodeHeight / 2}
                                    x2={conn.to.x}
                                    y2={conn.to.y - nodeHeight / 2}
                                    stroke="#4b5563"
                                    strokeWidth={2}
                                />
                            ))}
                            
                            {/* Nodes */}
                            {Object.entries(positions).map(([nodeId, pos]) => {
                                const isSelected = nodeId === selectedNode;
                                const isStart = nodeId === startNode;
                                const isEnd = isTerminal(nodeId);
                                const orphan = isOrphan(nodeId);
                                
                                let fill = '#1a1a2e';
                                let stroke = '#4b5563';
                                let strokeWidth = 2;
                                
                                if (isSelected) {
                                    fill = '#3730a3';
                                    stroke = '#818cf8';
                                    strokeWidth = 3;
                                }
                                if (isStart) {
                                    stroke = '#10b981';
                                } else if (orphan) {
                                    stroke = '#ef4444';
                                } else if (isEnd) {
                                    stroke = '#f59e0b';
                                }
                                
                                const title = nodes[nodeId]?.content?.en?.match(/^#\s+(.+)$/m)?.[1]?.slice(0, 15) || nodeId;
                                
                                return (
                                    <g
                                        key={nodeId}
                                        style={{ cursor: 'pointer' }}
                                        onClick={() => { onSelectNode(nodeId); onClose(); }}
                                    >
                                        <rect
                                            x={pos.x - nodeWidth / 2 + 10}
                                            y={pos.y - nodeHeight / 2}
                                            width={nodeWidth - 20}
                                            height={nodeHeight}
                                            rx={8}
                                            fill={fill}
                                            stroke={stroke}
                                            strokeWidth={strokeWidth}
                                        />
                                        <text
                                            x={pos.x}
                                            y={pos.y - 6}
                                            textAnchor="middle"
                                            dominantBaseline="middle"
                                            fill="#fff"
                                            fontSize="11"
                                            fontWeight="500"
                                        >
                                            {title.length > 12 ? title.slice(0, 10) + '..' : title}
                                        </text>
                                        <text
                                            x={pos.x}
                                            y={pos.y + 10}
                                            textAnchor="middle"
                                            dominantBaseline="middle"
                                            fill="#9ca3af"
                                            fontSize="9"
                                            fontFamily="monospace"
                                        >
                                            {nodeId.length > 14 ? nodeId.slice(0, 12) + '..' : nodeId}
                                        </text>
                                    </g>
                                );
                            })}
                        </svg>
                    </div>
                </div>
            );
        };
        
        // ============================================================
        // Default empty scenario
        // ============================================================
        const createEmptyScenario = () => ({
            meta: {
                title: { en: "New Scenario", it: "Nuovo scenario" },
                description: { en: "", it: "" },
                author: ""
            },
            startNode: "start",
            nodes: {
                "start": {
                    content: {
                        en: "# Welcome\n\nEdit this content to begin.",
                        it: "# Benvenuto\n\nModifica questo contenuto per iniziare."
                    },
                    choices: [],
                    resources: []
                }
            }
        });
        
        // ============================================================
        // Node List Component
        // ============================================================
        const NodeList = ({ scenario, selectedNode, onSelectNode, startNode, showMap, onToggleMap }) => {
            const nodeIds = Object.keys(scenario.nodes);
            
            const getNodeTitle = (nodeId) => {
                const content = scenario.nodes[nodeId]?.content?.en || '';
                const match = content.match(/^#\s+(.+)$/m);
                return match ? match[1].replace(/\*\*/g, '').slice(0, 30) : 'Untitled';
            };
            
            const isTerminal = (nodeId) => {
                const choices = scenario.nodes[nodeId]?.choices || [];
                return choices.length === 0;
            };
            
            const getNodeLevelInfo = (nodeId) => {
                const info = getNodeLevel(nodeId, scenario.nodes, startNode);
                if (info.level === 0) return 'orphan';
                return `L${info.level}-P${info.position}`;
            };
            
            const getParentNode = (nodeId) => {
                for (const [id, node] of Object.entries(scenario.nodes)) {
                    if (node.choices) {
                        for (const choice of node.choices) {
                            if (choice.next === nodeId) {
                                return id;
                            }
                        }
                    }
                }
                return null;
            };
            
            return (
                <>
                    {/* View toggle */}
                    <div style={{ padding: '0.5rem', borderBottom: '1px solid #2a2a4a', display: 'flex', gap: '0.5rem' }}>
                        <button 
                            className={`btn ${!showMap ? 'btn-primary' : 'btn-secondary'}`}
                            onClick={() => onToggleMap(false)}
                            style={{ flex: 1, fontSize: '0.75rem' }}
                        >
                            List
                        </button>
                        <button 
                            className={`btn ${showMap ? 'btn-primary' : 'btn-secondary'}`}
                            onClick={() => onToggleMap(true)}
                            style={{ flex: 1, fontSize: '0.75rem' }}
                        >
                            Map
                        </button>
                    </div>
                    
                    {showMap ? (
                        <TreeMapOverlay
                            nodes={scenario.nodes}
                            startNode={startNode}
                            selectedNode={selectedNode}
                            onSelectNode={onSelectNode}
                            onClose={() => onToggleMap(false)}
                        />
                    ) : (
                        <div className="node-list">
                            {nodeIds.map(nodeId => {
                                const parent = getParentNode(nodeId);
                                return (
                                    <div
                                        key={nodeId}
                                        className={`node-item ${selectedNode === nodeId ? 'selected' : ''} ${nodeId === startNode ? 'start-node' : ''} ${isTerminal(nodeId) ? 'terminal' : ''}`}
                                        onClick={() => onSelectNode(nodeId)}
                                    >
                                        <div className="node-title">{getNodeTitle(nodeId)}</div>
                                        <div className="node-id-small">{nodeId}</div>
                                        <div className="node-badges">
                                            <span className="badge">{getNodeLevelInfo(nodeId)}</span>
                                            {parent && <span className="badge">‚Üê {parent}</span>}
                                            {nodeId === startNode && <span className="badge badge-start">START</span>}
                                            {isTerminal(nodeId) && <span className="badge badge-terminal">END</span>}
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    )}
                </>
            );
        };
        
        // ============================================================
        // Choice Editor Component
        // ============================================================
        const ChoiceEditor = ({ choice, index, nodeIds, parentNodeId, onChange, onRemove, onCreateNode }) => {
            const [showCreatePopup, setShowCreatePopup] = useState(false);
            
            const handleTargetChange = (e) => {
                const value = e.target.value;
                if (value === '__CREATE_NEW__') {
                    setShowCreatePopup(true);
                } else {
                    onChange({ ...choice, next: value });
                }
            };
            
            const handleNodeCreated = (newNodeId) => {
                onChange({ ...choice, next: newNodeId });
                setShowCreatePopup(false);
            };
            
            return (
                <div className="choice-item">
                    <div className="choice-header">
                        <span className="choice-number">Choice {index + 1}</span>
                        <button className="btn btn-danger" onClick={onRemove} style={{ padding: '0.25rem 0.5rem', fontSize: '0.75rem' }}>
                            Remove
                        </button>
                    </div>
                    <div className="form-row">
                        <div className="form-group">
                            <label className="form-label">Text (EN)</label>
                            <input
                                type="text"
                                className="form-input"
                                value={choice.text?.en || ''}
                                onChange={(e) => onChange({ ...choice, text: { ...choice.text, en: e.target.value } })}
                                placeholder="Choice text in English"
                            />
                        </div>
                        <div className="form-group">
                            <label className="form-label">Text (IT)</label>
                            <input
                                type="text"
                                className="form-input"
                                value={choice.text?.it || ''}
                                onChange={(e) => onChange({ ...choice, text: { ...choice.text, it: e.target.value } })}
                                placeholder="Testo della scelta in italiano"
                            />
                        </div>
                    </div>
                    <div className="form-group">
                        <label className="form-label">Target Node</label>
                        <select
                            className="form-select"
                            style={{ width: '100%' }}
                            value={choice.next || ''}
                            onChange={handleTargetChange}
                        >
                            <option value="">-- Select target node --</option>
                            <option value="__CREATE_NEW__" style={{ fontWeight: 'bold', color: '#10b981' }}>+ Create new node...</option>
                            <optgroup label="Existing nodes">
                                {nodeIds.map(id => (
                                    <option key={id} value={id}>{id}</option>
                                ))}
                            </optgroup>
                        </select>
                    </div>
                    
                    {showCreatePopup && (
                        <CreateNodePopup
                            parentNodeId={parentNodeId}
                            existingNodeIds={nodeIds}
                            onCreateNode={onCreateNode}
                            onCreated={handleNodeCreated}
                            onClose={() => setShowCreatePopup(false)}
                        />
                    )}
                </div>
            );
        };
        
        // ============================================================
        // Create Node Popup Component
        // ============================================================
        const CreateNodePopup = ({ parentNodeId, existingNodeIds, onCreateNode, onCreated, onClose }) => {
            const suggestedId = (() => {
                // Simple suggestion based on parent
                let base = `${parentNodeId}_child`;
                let counter = 1;
                let id = base;
                while (existingNodeIds.includes(id)) {
                    id = `${base}_${counter}`;
                    counter++;
                }
                return id;
            })();
            
            const [nodeId, setNodeId] = useState(suggestedId);
            const [contentEn, setContentEn] = useState('# New Node\n\nEdit this content.');
            const [contentIt, setContentIt] = useState('# Nuovo nodo\n\nModifica questo contenuto.');
            const [error, setError] = useState('');
            
            const handleCreate = () => {
                // Validate node ID
                const cleanId = nodeId.trim().replace(/[^a-zA-Z0-9_]/g, '_');
                if (!cleanId) {
                    setError('Node ID is required');
                    return;
                }
                if (existingNodeIds.includes(cleanId)) {
                    setError('Node ID already exists');
                    return;
                }
                
                // Create the node
                const newNode = {
                    content: { en: contentEn, it: contentIt },
                    choices: [],
                    resources: []
                };
                
                onCreateNode(cleanId, newNode);
                onCreated(cleanId);
            };
            
            return (
                <div className="create-node-popup">
                    <div className="create-node-content">
                        <div className="create-node-header">
                            <h3>Create New Node</h3>
                            <button className="btn btn-secondary" onClick={onClose} style={{ padding: '0.25rem 0.5rem' }}>‚úï</button>
                        </div>
                        
                        <div className="form-group">
                            <label className="form-label">Node ID (internal name)</label>
                            <input
                                type="text"
                                className="form-input"
                                value={nodeId}
                                onChange={(e) => { setNodeId(e.target.value); setError(''); }}
                                placeholder="unique_node_id"
                            />
                            {error && <div style={{ color: '#ef4444', fontSize: '0.75rem', marginTop: '0.25rem' }}>{error}</div>}
                        </div>
                        
                        <div className="form-group">
                            <label className="form-label">Content (EN) - Markdown</label>
                            <textarea
                                className="form-input"
                                rows={4}
                                value={contentEn}
                                onChange={(e) => setContentEn(e.target.value)}
                                placeholder="# Title&#10;&#10;Content..."
                            />
                        </div>
                        
                        <div className="form-group">
                            <label className="form-label">Content (IT) - Markdown</label>
                            <textarea
                                className="form-input"
                                rows={4}
                                value={contentIt}
                                onChange={(e) => setContentIt(e.target.value)}
                                placeholder="# Titolo&#10;&#10;Contenuto..."
                            />
                        </div>
                        
                        <div className="form-info">
                            You can add choices and resources after creating the node.
                        </div>
                        
                        <div style={{ display: 'flex', gap: '0.5rem', marginTop: '1rem' }}>
                            <button className="btn btn-success" onClick={handleCreate}>Create Node</button>
                            <button className="btn btn-secondary" onClick={onClose}>Cancel</button>
                        </div>
                    </div>
                </div>
            );
        };
        
        // ============================================================
        // Resource Editor Component
        // ============================================================
        const ResourceEditor = ({ resource, index, onChange, onRemove }) => {
            return (
                <div className="resource-item">
                    <div className="resource-header">
                        <span className="choice-number">Resource {index + 1}</span>
                        <button className="btn btn-danger" onClick={onRemove} style={{ padding: '0.25rem 0.5rem', fontSize: '0.75rem' }}>
                            Remove
                        </button>
                    </div>
                    <div className="form-row">
                        <div className="form-group">
                            <label className="form-label">Type</label>
                            <select
                                className="form-select"
                                style={{ width: '100%' }}
                                value={resource.type || 'link'}
                                onChange={(e) => onChange({ ...resource, type: e.target.value })}
                            >
                                <option value="link">Link (opens in new tab)</option>
                                <option value="download">Download</option>
                                <option value="video">Video</option>
                            </select>
                        </div>
                        <div className="form-group">
                            <label className="form-label">URL</label>
                            <input
                                type="text"
                                className="form-input"
                                value={resource.url || ''}
                                onChange={(e) => onChange({ ...resource, url: e.target.value })}
                                placeholder="docs/file.pdf or https://..."
                            />
                        </div>
                    </div>
                    <div className="form-row">
                        <div className="form-group">
                            <label className="form-label">Label (EN)</label>
                            <input
                                type="text"
                                className="form-input"
                                value={resource.label?.en || ''}
                                onChange={(e) => onChange({ ...resource, label: { ...resource.label, en: e.target.value } })}
                                placeholder="Resource label"
                            />
                        </div>
                        <div className="form-group">
                            <label className="form-label">Label (IT)</label>
                            <input
                                type="text"
                                className="form-input"
                                value={resource.label?.it || ''}
                                onChange={(e) => onChange({ ...resource, label: { ...resource.label, it: e.target.value } })}
                                placeholder="Etichetta risorsa"
                            />
                        </div>
                    </div>
                </div>
            );
        };
        
        // ============================================================
        // Node Editor Component
        // ============================================================
        const NodeEditor = ({ nodeId, node, nodeIds, startNode, onUpdateNode, onDeleteNode, onSetStartNode, onRenameNode, onCreateNode }) => {
            const [newNodeId, setNewNodeId] = useState(nodeId);
            const [showRename, setShowRename] = useState(false);
            
            const handleRename = () => {
                if (newNodeId && newNodeId !== nodeId && !nodeIds.includes(newNodeId)) {
                    onRenameNode(nodeId, newNodeId);
                    setShowRename(false);
                }
            };
            
            const updateContent = (lang, value) => {
                onUpdateNode(nodeId, {
                    ...node,
                    content: { ...node.content, [lang]: value }
                });
            };
            
            const updateChoice = (index, choice) => {
                const newChoices = [...(node.choices || [])];
                newChoices[index] = choice;
                onUpdateNode(nodeId, { ...node, choices: newChoices });
            };
            
            const addChoice = () => {
                const newChoices = [...(node.choices || []), { text: { en: '', it: '' }, next: '' }];
                onUpdateNode(nodeId, { ...node, choices: newChoices });
            };
            
            const removeChoice = (index) => {
                const newChoices = (node.choices || []).filter((_, i) => i !== index);
                onUpdateNode(nodeId, { ...node, choices: newChoices });
            };
            
            const updateResource = (index, resource) => {
                const newResources = [...(node.resources || [])];
                newResources[index] = resource;
                onUpdateNode(nodeId, { ...node, resources: newResources });
            };
            
            const addResource = () => {
                const newResources = [...(node.resources || []), { type: 'link', label: { en: '', it: '' }, url: '' }];
                onUpdateNode(nodeId, { ...node, resources: newResources });
            };
            
            const removeResource = (index) => {
                const newResources = (node.resources || []).filter((_, i) => i !== index);
                onUpdateNode(nodeId, { ...node, resources: newResources });
            };
            
            return (
                <div className="editor-content">
                    {/* Node ID and actions */}
                    <div className="form-section">
                        <h3>
                            Node: {nodeId}
                            {nodeId === startNode && <span className="badge badge-start" style={{ marginLeft: '0.5rem' }}>START NODE</span>}
                        </h3>
                        <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
                            {!showRename ? (
                                <button className="btn btn-secondary" onClick={() => setShowRename(true)}>
                                    Rename
                                </button>
                            ) : (
                                <div style={{ display: 'flex', gap: '0.5rem', alignItems: 'center' }}>
                                    <input
                                        type="text"
                                        className="form-input"
                                        style={{ width: '150px' }}
                                        value={newNodeId}
                                        onChange={(e) => setNewNodeId(e.target.value.replace(/[^a-zA-Z0-9_]/g, ''))}
                                        placeholder="new_node_id"
                                    />
                                    <button className="btn btn-primary" onClick={handleRename}>OK</button>
                                    <button className="btn btn-secondary" onClick={() => { setShowRename(false); setNewNodeId(nodeId); }}>Cancel</button>
                                </div>
                            )}
                            {nodeId !== startNode && (
                                <button className="btn btn-success" onClick={() => onSetStartNode(nodeId)}>
                                    Set as Start
                                </button>
                            )}
                            {nodeId !== startNode && (
                                <button className="btn btn-danger" onClick={() => onDeleteNode(nodeId)}>
                                    Delete Node
                                </button>
                            )}
                        </div>
                    </div>
                    
                    {/* Content */}
                    <div className="form-section">
                        <h3>üìù Content</h3>
                        <div className="form-group">
                            <label className="form-label">English Content (Markdown)</label>
                            <textarea
                                className="form-input form-textarea"
                                value={node.content?.en || ''}
                                onChange={(e) => updateContent('en', e.target.value)}
                                placeholder="# Title&#10;&#10;Content with **bold** and *italic*..."
                            />
                        </div>
                        <div className="form-group">
                            <label className="form-label">Italian Content (Markdown)</label>
                            <textarea
                                className="form-input form-textarea"
                                value={node.content?.it || ''}
                                onChange={(e) => updateContent('it', e.target.value)}
                                placeholder="# Titolo&#10;&#10;Contenuto con **grassetto** e *corsivo*..."
                            />
                        </div>
                    </div>
                    
                    {/* Choices */}
                    <div className="form-section">
                        <h3>üîÄ Choices ({(node.choices || []).length})</h3>
                        {(node.choices || []).map((choice, index) => (
                            <ChoiceEditor
                                key={index}
                                choice={choice}
                                index={index}
                                nodeIds={nodeIds}
                                parentNodeId={nodeId}
                                onChange={(c) => updateChoice(index, c)}
                                onRemove={() => removeChoice(index)}
                                onCreateNode={onCreateNode}
                            />
                        ))}
                        <button className="add-button" onClick={addChoice}>
                            + Add Choice
                        </button>
                        {(node.choices || []).length === 0 && (
                            <p style={{ fontSize: '0.8rem', color: '#9ca3af', marginTop: '0.5rem', textAlign: 'center' }}>
                                No choices = terminal node (end of path)
                            </p>
                        )}
                    </div>
                    
                    {/* Resources */}
                    <div className="form-section">
                        <h3>üìé Resources ({(node.resources || []).length})</h3>
                        {(node.resources || []).map((resource, index) => (
                            <ResourceEditor
                                key={index}
                                resource={resource}
                                index={index}
                                onChange={(r) => updateResource(index, r)}
                                onRemove={() => removeResource(index)}
                            />
                        ))}
                        <button className="add-button" onClick={addResource}>
                            + Add Resource
                        </button>
                    </div>
                </div>
            );
        };
        
        // ============================================================
        // Meta Editor Modal
        // ============================================================
        const MetaEditor = ({ meta, onUpdate, onClose }) => {
            const [localMeta, setLocalMeta] = useState(meta);
            
            const handleSave = () => {
                onUpdate(localMeta);
                onClose();
            };
            
            return (
                <div className="meta-editor">
                    <div className="meta-editor-content">
                        <div className="meta-editor-header">
                            <h2>Scenario Settings</h2>
                            <button className="btn btn-secondary" onClick={onClose}>‚úï</button>
                        </div>
                        
                        <div className="form-group">
                            <label className="form-label">Title (EN)</label>
                            <input
                                type="text"
                                className="form-input"
                                value={localMeta.title?.en || ''}
                                onChange={(e) => setLocalMeta({ ...localMeta, title: { ...localMeta.title, en: e.target.value } })}
                            />
                        </div>
                        
                        <div className="form-group">
                            <label className="form-label">Title (IT)</label>
                            <input
                                type="text"
                                className="form-input"
                                value={localMeta.title?.it || ''}
                                onChange={(e) => setLocalMeta({ ...localMeta, title: { ...localMeta.title, it: e.target.value } })}
                            />
                        </div>
                        
                        <div className="form-group">
                            <label className="form-label">Description (EN)</label>
                            <textarea
                                className="form-input"
                                rows={2}
                                value={localMeta.description?.en || ''}
                                onChange={(e) => setLocalMeta({ ...localMeta, description: { ...localMeta.description, en: e.target.value } })}
                            />
                        </div>
                        
                        <div className="form-group">
                            <label className="form-label">Description (IT)</label>
                            <textarea
                                className="form-input"
                                rows={2}
                                value={localMeta.description?.it || ''}
                                onChange={(e) => setLocalMeta({ ...localMeta, description: { ...localMeta.description, it: e.target.value } })}
                            />
                        </div>
                        
                        <div className="form-group">
                            <label className="form-label">Author</label>
                            <input
                                type="text"
                                className="form-input"
                                value={localMeta.author || ''}
                                onChange={(e) => setLocalMeta({ ...localMeta, author: e.target.value })}
                            />
                        </div>
                        
                        <div style={{ display: 'flex', gap: '0.5rem', marginTop: '1.5rem' }}>
                            <button className="btn btn-primary" onClick={handleSave}>Save</button>
                            <button className="btn btn-secondary" onClick={onClose}>Cancel</button>
                        </div>
                    </div>
                </div>
            );
        };
        
        // ============================================================
        // Main App Component
        // ============================================================
        const ScenarioEditor = () => {
            const [scenario, setScenario] = useState(createEmptyScenario());
            const [selectedNode, setSelectedNode] = useState('start');
            const [hasChanges, setHasChanges] = useState(false);
            const [showMetaEditor, setShowMetaEditor] = useState(false);
            const [showMap, setShowMap] = useState(false);
            const [fileName, setFileName] = useState('scenario-data.json');
            const fileInputRef = useRef(null);
            
            const nodeIds = Object.keys(scenario.nodes);
            
            // Load file
            const handleLoadFile = (e) => {
                const file = e.target.files[0];
                if (file) {
                    setFileName(file.name);
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            setScenario(data);
                            setSelectedNode(data.startNode || Object.keys(data.nodes)[0]);
                            setHasChanges(false);
                        } catch (err) {
                            alert('Error parsing JSON file: ' + err.message);
                        }
                    };
                    reader.readAsText(file);
                }
                // Reset file input to allow re-selecting the same file
                e.target.value = '';
            };
            
            // Save file
            const handleSaveFile = () => {
                const json = JSON.stringify(scenario, null, 4);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                a.click();
                URL.revokeObjectURL(url);
                // Note: We can't know if user actually saved the file
                // Show a confirmation dialog
                if (confirm('Did you save the file successfully?\n\nClick OK if saved, Cancel if not.')) {
                    setHasChanges(false);
                }
            };
            
            // New scenario
            const handleNewScenario = () => {
                if (hasChanges && !confirm('You have unsaved changes. Create new scenario anyway?')) {
                    return;
                }
                setScenario(createEmptyScenario());
                setSelectedNode('start');
                setFileName('scenario-data.json');
                setHasChanges(false);
            };
            
            // Update node
            const handleUpdateNode = (nodeId, node) => {
                setScenario(prev => ({
                    ...prev,
                    nodes: { ...prev.nodes, [nodeId]: node }
                }));
                setHasChanges(true);
            };
            
            // Create node (called from ChoiceEditor popup)
            const handleCreateNode = (newNodeId, newNode) => {
                setScenario(prev => ({
                    ...prev,
                    nodes: {
                        ...prev.nodes,
                        [newNodeId]: newNode
                    }
                }));
                setHasChanges(true);
            };
            
            // Delete node
            const handleDeleteNode = (nodeId) => {
                if (!confirm(`Delete node "${nodeId}"? This cannot be undone.`)) {
                    return;
                }
                
                const newNodes = { ...scenario.nodes };
                delete newNodes[nodeId];
                
                // Also remove references to this node in choices
                Object.keys(newNodes).forEach(id => {
                    if (newNodes[id].choices) {
                        newNodes[id].choices = newNodes[id].choices.filter(c => c.next !== nodeId);
                    }
                });
                
                setScenario(prev => ({ ...prev, nodes: newNodes }));
                setSelectedNode(Object.keys(newNodes)[0]);
                setHasChanges(true);
            };
            
            // Set start node
            const handleSetStartNode = (nodeId) => {
                setScenario(prev => ({ ...prev, startNode: nodeId }));
                setHasChanges(true);
            };
            
            // Rename node
            const handleRenameNode = (oldId, newId) => {
                const newNodes = {};
                Object.keys(scenario.nodes).forEach(id => {
                    const key = id === oldId ? newId : id;
                    newNodes[key] = { ...scenario.nodes[id] };
                    
                    // Update choices that point to old ID
                    if (newNodes[key].choices) {
                        newNodes[key].choices = newNodes[key].choices.map(c => 
                            c.next === oldId ? { ...c, next: newId } : c
                        );
                    }
                });
                
                setScenario(prev => ({
                    ...prev,
                    startNode: prev.startNode === oldId ? newId : prev.startNode,
                    nodes: newNodes
                }));
                setSelectedNode(newId);
                setHasChanges(true);
            };
            
            // Update meta
            const handleUpdateMeta = (meta) => {
                setScenario(prev => ({ ...prev, meta }));
                setHasChanges(true);
            };
            
            return (
                <div className="editor-container">
                    {/* Sidebar */}
                    <div className="sidebar">
                        <div className="sidebar-header">
                            <h1>Scenario Editor</h1>
                            <div className="sidebar-actions">
                                <button className="btn btn-secondary" onClick={handleNewScenario}>New</button>
                                <button className="btn btn-secondary" onClick={() => fileInputRef.current?.click()}>Open</button>
                                <button className="btn btn-primary" onClick={handleSaveFile}>Save</button>
                            </div>
                            <input
                                ref={fileInputRef}
                                type="file"
                                accept=".json"
                                className="hidden-input"
                                onChange={handleLoadFile}
                            />
                        </div>
                        
                        <NodeList
                            scenario={scenario}
                            selectedNode={selectedNode}
                            onSelectNode={setSelectedNode}
                            startNode={scenario.startNode}
                            showMap={showMap}
                            onToggleMap={setShowMap}
                        />
                    </div>
                    
                    {/* Main Editor */}
                    <div className="main-editor">
                        <div className="editor-header">
                            <div>
                                <strong>{fileName}</strong>
                                <span style={{ marginLeft: '1rem', color: '#6b7280' }}>
                                    {nodeIds.length} nodes
                                </span>
                            </div>
                            <button className="btn btn-secondary" onClick={() => setShowMetaEditor(true)}>
                                ‚öôÔ∏è Settings
                            </button>
                        </div>
                        
                        {selectedNode && scenario.nodes[selectedNode] ? (
                            <NodeEditor
                                nodeId={selectedNode}
                                node={scenario.nodes[selectedNode]}
                                nodeIds={nodeIds}
                                startNode={scenario.startNode}
                                onUpdateNode={handleUpdateNode}
                                onDeleteNode={handleDeleteNode}
                                onSetStartNode={handleSetStartNode}
                                onRenameNode={handleRenameNode}
                                onCreateNode={handleCreateNode}
                            />
                        ) : (
                            <div className="empty-state">
                                <h2>No node selected</h2>
                                <p>Select a node from the sidebar or create a new one.</p>
                            </div>
                        )}
                        
                        <div className="status-bar">
                            <span className={hasChanges ? 'status-unsaved' : 'status-saved'}>
                                {hasChanges ? '‚óè Unsaved changes' : '‚úì Saved'}
                            </span>
                            <span>Start node: {scenario.startNode}</span>
                        </div>
                    </div>
                    
                    {/* Meta Editor Modal */}
                    {showMetaEditor && (
                        <MetaEditor
                            meta={scenario.meta}
                            onUpdate={handleUpdateMeta}
                            onClose={() => setShowMetaEditor(false)}
                        />
                    )}
                </div>
            );
        };
        
        ReactDOM.createRoot(document.getElementById('root')).render(<ScenarioEditor />);
    </script>
</body>
</html>
